{"version":3,"sources":["CustomGestures.js","displayUtils.js","App.js","index.js"],"names":["zero","GestureDescription","one","two","three","four","five","addCurl","Finger","Thumb","FingerCurl","FullCurl","Index","Middle","Ring","Pinky","HalfCurl","NoCurl","addDirection","FingerDirection","VerticalUp","labels","GE","fp","displayHand","image","classification","marks","ctx","predictionRef","w","width","h","height","clearRect","fillStyle","strokeStyle","displayHandLandmarks","marks_","Array","i","x","y","manual_gesture","estimate","finalNumPrediction","undefined","gestures","length","maxConfidence","maxConfidenceIndex","forEach","gesture","index","confidence","numPrediction","name","current","innerText","x1","x2","y1","y2","m","x_mid","y_mid","factors","guesses","nGuess","scale_fac","w_","Math","max","x_min","y_min","drawImage","window","webcamEl","img_temp","getImageData","pix","Float32Array","cur","data","tensor","tf","recognizer","recognized","predict","bufferSync","values","charindex","best_confidence","best_guess","j","lineWidth","strokeRect","fingers","range","color","finger","beginPath","arc","PI","fill","moveTo","lineTo","stroke","baseX","baseY","displayEmpty","canvas","App","numContainerRef","useRef","letterContainerRef","numMode","webcamRef","canvasRef","numPredictionText","letterPredictionText","numPredictions","letterPredictions","zeroDiv","oneDiv","twoDiv","threeDiv","fourDiv","fiveDiv","mDiv","lDiv","hDiv","updateNumUI","currPrediction","predictionsArr","push","shift","countArr","updateText","numCounts","parseInt","style","updateLetterUI","onResults","results","a","getContext","save","multiHandLandmarks","multiHandedness","letterPrediction","restore","sendPicture","hands","video","readyState","vw","videoWidth","vh","videoHeight","cam","console","log","Camera","onFrame","current_screenshot","send","start","setupWidgets","Hands","locateFile","file","setOptions","maxNumHands","minDetectionConfidence","minTrackingConfidence","add","softmax","setInterval","useEffect","className","ref","textAlign","type","id","onChange","classList","remove","for","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.2ee89355.chunk.js","sourcesContent":["// Import dependencies\r\nimport { Finger, FingerCurl, FingerDirection, GestureDescription } from 'fingerpose';\r\n\r\nexport const zero = new GestureDescription('0');\r\nexport const one = new GestureDescription('1');\r\nexport const two = new GestureDescription('2');\r\nexport const three = new GestureDescription('3');\r\nexport const four = new GestureDescription('4');\r\nexport const five = new GestureDescription('5');\r\n\r\n// zero\r\nzero.addCurl(Finger.Thumb, FingerCurl.FullCurl, 1.0);\r\nzero.addCurl(Finger.Index, FingerCurl.FullCurl, 1.0);\r\nzero.addCurl(Finger.Middle, FingerCurl.FullCurl, 1.0);\r\nzero.addCurl(Finger.Ring, FingerCurl.FullCurl, 1.0);\r\nzero.addCurl(Finger.Pinky, FingerCurl.FullCurl, 1.0);\r\n\r\n// one\r\none.addCurl(Finger.Thumb, FingerCurl.HalfCurl, 1.0);\r\none.addCurl(Finger.Index, FingerCurl.NoCurl, 1.0);\r\none.addDirection(Finger.Index, FingerDirection.VerticalUp, 1.0);\r\none.addCurl(Finger.Middle, FingerCurl.FullCurl, 1.0);\r\none.addCurl(Finger.Ring, FingerCurl.FullCurl, 1.0);\r\none.addCurl(Finger.Pinky, FingerCurl.FullCurl, 1.0);\r\n\r\n// Two\r\ntwo.addCurl(Finger.Thumb, FingerCurl.HalfCurl, 1.0);\r\ntwo.addCurl(Finger.Index, FingerCurl.NoCurl, 1.0);\r\ntwo.addDirection(Finger.Index, FingerDirection.VerticalUp, 1.0);\r\n\r\ntwo.addCurl(Finger.Middle, FingerCurl.NoCurl, 1.0);\r\ntwo.addDirection(Finger.Middle, FingerDirection.VerticalUp, 1.0);\r\n\r\ntwo.addCurl(Finger.Ring, FingerCurl.FullCurl, 1.0);\r\ntwo.addCurl(Finger.Pinky, FingerCurl.FullCurl, 1.0);\r\n\r\n// Three\r\nthree.addCurl(Finger.Thumb, FingerCurl.HalfCurl, 1.0);\r\n\r\nthree.addCurl(Finger.Index, FingerCurl.NoCurl, 1.0);\r\nthree.addDirection(Finger.Index, FingerDirection.VerticalUp, 1.0);\r\n\r\nthree.addCurl(Finger.Middle, FingerCurl.NoCurl, 1.0);\r\nthree.addDirection(Finger.Middle, FingerDirection.VerticalUp, 1.0);\r\n\r\nthree.addCurl(Finger.Ring, FingerCurl.NoCurl, 1.0);\r\nthree.addDirection(Finger.Ring, FingerDirection.VerticalUp, 1.0);\r\n\r\nthree.addCurl(Finger.Pinky, FingerCurl.FullCurl, 1.0);\r\n\r\n// four\r\nfour.addCurl(Finger.Thumb, FingerCurl.HalfCurl, 1.0);\r\n\r\nfour.addCurl(Finger.Index, FingerCurl.NoCurl, 1.0);\r\nfour.addDirection(Finger.Index, FingerDirection.VerticalUp, 1.0);\r\n\r\nfour.addCurl(Finger.Middle, FingerCurl.NoCurl, 1.0);\r\nfour.addDirection(Finger.Middle, FingerDirection.VerticalUp, 1.0);\r\n\r\nfour.addCurl(Finger.Ring, FingerCurl.NoCurl, 1.0);\r\nfour.addDirection(Finger.Ring, FingerDirection.VerticalUp, 1.0);\r\n\r\nfour.addCurl(Finger.Pinky, FingerCurl.NoCurl, 1.0);\r\nfour.addDirection(Finger.Pinky, FingerDirection.VerticalUp, 1.0);\r\n\r\n// five\r\nfive.addCurl(Finger.Thumb, FingerCurl.NoCurl, 1.0);\r\nfive.addCurl(Finger.Index, FingerCurl.NoCurl, 1.0);\r\nfive.addCurl(Finger.Middle, FingerCurl.NoCurl, 1.0);\r\nfive.addCurl(Finger.Ring, FingerCurl.NoCurl, 1.0);\r\nfive.addCurl(Finger.Pinky, FingerCurl.NoCurl, 1.0);\r\n","import * as tf from '@tensorflow/tfjs';\r\n\r\n// recognize gesture off of landmarks\r\nimport * as fp from 'fingerpose';\r\nimport { zero, one, two, three, four, five } from './CustomGestures';\r\n\r\nconst labels = [\r\n  'M', 'L', 'H'\r\n];\r\n\r\nconst GE = new fp.GestureEstimator([\r\n  zero, one, two, three, four, five\r\n]);\r\n\r\n// draw green boundary around the hand\r\nexport const displayHand = (image, classification, marks, ctx, predictionRef) => {\r\n  const w = image.width;\r\n  const h = image.height;\r\n  // let score = classification.score;\r\n\r\n  // console.log(marks);\r\n\r\n  ctx.clearRect(0, 0, w, h);\r\n  ctx.fillStyle = 'green';\r\n  ctx.strokeStyle = 'rgba(171, 235, 52, 1)';\r\n\r\n  // draw landmarks\r\n  displayHandLandmarks(image, marks, ctx);\r\n\r\n  const marks_ = new Array(21);\r\n  for (let i = 0; i < 21; i++) {\r\n    marks_[i] = [marks[i].x * w, marks[i].y * h, 0];\r\n  }\r\n\r\n  // console.log(marks_);\r\n\r\n  const manual_gesture = GE.estimate(\r\n    marks_, 7.5 // 7.5 is minimum confidence out of 10\r\n  );\r\n\r\n  // console.log(manual_gesture);\r\n  let finalNumPrediction = null;\r\n  if (manual_gesture.gestures !== undefined && manual_gesture.gestures.length > 0) {\r\n    let maxConfidence = -1;\r\n    let maxConfidenceIndex = -1;\r\n    manual_gesture.gestures.forEach((gesture, index) => {\r\n      if (gesture.confidence > maxConfidence) {\r\n        maxConfidence = gesture.confidence;\r\n        maxConfidenceIndex = index;\r\n      }\r\n    });\r\n\r\n    const numPrediction = manual_gesture.gestures[maxConfidenceIndex].name;\r\n    // value that will be return at the end\r\n    finalNumPrediction = numPrediction;\r\n    // console.log(predictionRef);\r\n    // predictionRef.current.innerText = numPrediction + ' is the best numeric guess from 1 to 5';\r\n    // console.log(manual_gesture.gestures[maxConfidenceIndex].name, 'is the best numeric guess from 1 to 5');\r\n  } else {\r\n    predictionRef.current.innerText = 'Found hand But gesture not recognized';\r\n  }\r\n\r\n  if (marks.length > 0) {\r\n    let x1 = 1; let x2 = 0; let y1 = 1; let y2 = 0;\r\n    marks.forEach(m => {\r\n      if (m.x < x1) x1 = m.x;\r\n      if (m.x > x2) x2 = m.x;\r\n      if (m.y < y1) y1 = m.y;\r\n      if (m.y > y2) y2 = m.y;\r\n    });\r\n\r\n    x1 *= w;\r\n    x2 *= w;\r\n    y1 *= h;\r\n    y2 *= h;\r\n\r\n    const x_mid = (x1 + x2) / 2;\r\n    const y_mid = (y1 + y2) / 2;\r\n    const factors = [0.5, 0.9, 1.2];\r\n\r\n    const guesses = new Array(factors.length);\r\n    const confidence = new Array(factors.length);\r\n\r\n    let nGuess = 0;\r\n    factors.forEach(scale_fac => {\r\n      const w_ = Math.max((x2 - x1) * scale_fac, (y2 - y1) * scale_fac);\r\n      // crop bound\r\n      const x_min = Math.max(0, x_mid - w_);\r\n      const y_min = Math.max(0, y_mid - w_);\r\n      // get image from video\r\n      // 64x64 rgba image on the left top corner of the canvas\r\n      ctx.drawImage(window.webcamEl, x_min, y_min, 2 * w_, 2 * w_, 0, 0, 64, 64);\r\n\r\n      const img_temp = ctx.getImageData(0, 0, 64, 64);\r\n\r\n      const pix = new Float32Array(64 * 64 * 3);\r\n      let cur = 0;\r\n      for (let i = 0; i < 64 * 64 * 4; i++) {\r\n        if (i % 4 !== 3) {\r\n          if (i % 4 === 2) { pix[cur - 2] = img_temp.data[i] / 255.0; }\r\n          if (i % 4 === 1) { pix[cur] = img_temp.data[i] / 255.0; }\r\n          if (i % 4 === 0) { pix[cur + 2] = img_temp.data[i] / 255.0; }\r\n          // pix[cur] = img_temp.data[i] / 255.0;\r\n          cur += 1;\r\n        }\r\n      }\r\n\r\n      // console.log(pix);\r\n\r\n      const tensor = tf.tensor4d(pix, [1, 64, 64, 3], 'float32');\r\n      // console.log(tensor.dataSync());\r\n      if (window.recognizer === null) return [finalNumPrediction, null];\r\n      const recognized = window.recognizer.predict(tensor).bufferSync().values;\r\n\r\n      // console.log(recognized);\r\n\r\n      let max = 0;\r\n      let charindex = -1;\r\n      for (let i = 0; i < recognized.length; i++) {\r\n        if (recognized[i] > max) {\r\n          max = recognized[i];\r\n          charindex = i;\r\n        }\r\n      }\r\n\r\n      confidence[nGuess] = max;\r\n      guesses[nGuess] = charindex;\r\n\r\n      nGuess += 1;\r\n    });\r\n\r\n    let best_confidence = confidence[0];\r\n    let best_guess = guesses[0];\r\n    for (let j = 1; j < nGuess; j++) {\r\n      if (best_confidence < confidence[j]) {\r\n        best_confidence = confidence[j];\r\n        best_guess = guesses[j];\r\n      }\r\n    }\r\n\r\n    // console.log(labels[best_guess], \"is the best letter guess out of 'MLH' with confidence:\", best_confidence);\r\n\r\n    // console.log(labels[charindex], recognized[charindex]);\r\n\r\n    // console.log(img_temp);\r\n\r\n    // ctx.scale(64 / img_temp.width, 64 / img_temp.height);\r\n    // ctx.putImageData(img_temp, 0, 0);\r\n\r\n    ctx.lineWidth = 5;\r\n    ctx.strokeRect(\r\n      x1, y1,\r\n      x2 - x1, y2 - y1\r\n    );\r\n\r\n    return [finalNumPrediction, labels[best_guess]];\r\n  }\r\n};\r\n\r\nconst displayHandLandmarks = (image, marks, ctx) => {\r\n  if (marks.length === 0) return;\r\n\r\n  // all inclusive\r\n  // 0 - base\r\n  // thumb 0 - 4\r\n  // index 5 - 8\r\n  // middle 9 - 12\r\n  // ring 13 - 16\r\n  // pinky 17 - 20\r\n  const fingers = [\r\n    { range: [1, 4], color: 'red' },\r\n    { range: [5, 8], color: 'blue' },\r\n    { range: [9, 12], color: 'yellow' },\r\n    { range: [13, 16], color: 'orange' },\r\n    { range: [17, 20], color: 'lime' }\r\n  ];\r\n\r\n  fingers.forEach(finger => {\r\n    for (let i = finger.range[0]; i < finger.range[1]; i++) {\r\n      const x1 = marks[i].x * image.width;\r\n      const y1 = marks[i].y * image.height;\r\n\r\n      // first dot\r\n      ctx.beginPath();\r\n      ctx.arc(x1, y1, 5, 0, 3 * Math.PI);\r\n      ctx.fillStyle = finger.color;\r\n      ctx.fill();\r\n\r\n      ctx.moveTo(x1, y1);\r\n\r\n      const x2 = marks[i + 1].x * image.width;\r\n      const y2 = marks[i + 1].y * image.height;\r\n\r\n      // line\r\n      ctx.lineTo(x2, y2);\r\n      ctx.lineWidth = 3;\r\n      ctx.strokeStyle = finger.color;\r\n      ctx.stroke();\r\n\r\n      // second dot\r\n      ctx.arc(x2, y2, 5, 0, 3 * Math.PI);\r\n      ctx.fillStyle = finger.color;\r\n      ctx.fill();\r\n    }\r\n  });\r\n\r\n  // connecting each finger to the base\r\n  const baseX = marks[0].x * image.width;\r\n  const baseY = marks[0].y * image.height;\r\n  fingers.forEach(finger => {\r\n    // first landmark in finger\r\n    const x = marks[finger.range[0]].x * image.width;\r\n    const y = marks[finger.range[0]].y * image.height;\r\n\r\n    ctx.moveTo(baseX, baseY);\r\n    ctx.lineTo(x, y);\r\n    ctx.lineWidth = 3;\r\n    ctx.strokeStyle = 'white';\r\n    ctx.stroke();\r\n  });\r\n};\r\n\r\n// draw red boundary around the entire screen when no hand is discovered\r\nexport const displayEmpty = (ctx, predictionRef) => {\r\n  ctx.strokeStyle = 'tomato';\r\n  ctx.lineWidth = 5;\r\n  ctx.strokeRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n  predictionRef.current.innerText = 'No Prediction';\r\n};\r\n","// import logo from './logo.svg';\r\n\r\nimport React, { useRef, useEffect, useState } from 'react';\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\nimport Webcam from 'react-webcam';\r\nimport './App.css';\r\n// hand recognition from webcam\r\nimport { Camera } from '@mediapipe/camera_utils/camera_utils';\r\nimport { Hands } from '@mediapipe/hands/hands';\r\n// tfjs model\r\n// import * as handpose from \"@tensorflow-models/handpose\";\r\n// display\r\nimport { displayHand, displayEmpty } from './displayUtils';\r\n\r\nfunction App () {\r\n  const numContainerRef = useRef(null);\r\n  const letterContainerRef = useRef(null);\r\n  const numMode = useRef(true);\r\n\r\n  const webcamRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n\r\n  const numPredictionText = useRef(null);\r\n  const letterPredictionText = useRef(null);\r\n\r\n  const numPredictions = useRef([]);\r\n  const letterPredictions = useRef([]);\r\n\r\n  const zeroDiv = useRef(null);\r\n  const oneDiv = useRef(null);\r\n  const twoDiv = useRef(null);\r\n  const threeDiv = useRef(null);\r\n  const fourDiv = useRef(null);\r\n  const fiveDiv = useRef(null);\r\n\r\n  const mDiv = useRef(null);\r\n  const lDiv = useRef(null);\r\n  const hDiv = useRef(null);\r\n\r\n  window.webcamEl = null;\r\n  window.recognizer = null;\r\n\r\n  const updateNumUI = (currPrediction) => {\r\n    const predictionsArr = numPredictions.current;\r\n\r\n    const updateNumCols = (countArr) => {\r\n      zeroDiv.current.style.height = (countArr[0] / 15 * 300) + 'px';\r\n      oneDiv.current.style.height = (countArr[1] / 15 * 300) + 'px';\r\n      twoDiv.current.style.height = (countArr[2] / 15 * 300) + 'px';\r\n      threeDiv.current.style.height = (countArr[3] / 15 * 300) + 'px';\r\n      fourDiv.current.style.height = (countArr[4] / 15 * 300) + 'px';\r\n      fiveDiv.current.style.height = (countArr[5] / 15 * 300) + 'px';\r\n    };\r\n\r\n    if (predictionsArr.length < 16) return predictionsArr.push(currPrediction);\r\n\r\n    predictionsArr.shift();\r\n    predictionsArr.push(currPrediction);\r\n\r\n    let updateText = true;\r\n    const numCounts = [0, 0, 0, 0, 0, 0];\r\n    for (let i = 0; i < 10; i++) {\r\n      numCounts[parseInt(predictionsArr[i])]++;\r\n\r\n      if (predictionsArr[i] !== currPrediction) updateText = false;\r\n    }\r\n    // console.log(numCounts);\r\n    updateNumCols(numCounts);\r\n    if (updateText) numPredictionText.current.innerText = currPrediction + ' is the best numeric guess from 1 to 5';\r\n  };\r\n\r\n  const updateLetterUI = (currPrediction) => {\r\n    const predictionsArr = letterPredictions.current;\r\n    const updateLetterCols = (countArr) => {\r\n      mDiv.current.style.height = (countArr[0] / 15 * 300) + 'px';\r\n      lDiv.current.style.height = (countArr[1] / 15 * 300) + 'px';\r\n      hDiv.current.style.height = (countArr[2] / 15 * 300) + 'px';\r\n    };\r\n    if (predictionsArr.length < 16) return predictionsArr.push(currPrediction);\r\n    else {\r\n      predictionsArr.shift();\r\n      predictionsArr.push(currPrediction);\r\n    }\r\n\r\n    let updateText = true;\r\n    // [M, L, H]\r\n    const numCounts = [0, 0, 0];\r\n    for (let i = 0; i < 10; i++) {\r\n      if (predictionsArr[i] === 'M') numCounts[0]++;\r\n      else if (predictionsArr[i] === 'L') numCounts[1]++;\r\n      else if (predictionsArr[i] === 'H') numCounts[2]++;\r\n      else return;\r\n\r\n      if (predictionsArr[i] !== currPrediction) updateText = false;\r\n    }\r\n    // console.log(numCounts);\r\n    updateLetterCols(numCounts);\r\n    if (updateText) letterPredictionText.current.innerText = currPrediction + ' is the best numeric guess from 1 to 5';\r\n  };\r\n\r\n  // called when image from webcam is successfully sent to the mediapipe hands model\r\n  const onResults = async (results) => {\r\n    if (results !== null) {\r\n      // results is a canvas\r\n      // console.log(results);\r\n    }\r\n\r\n    const ctx = canvasRef.current.getContext('2d');\r\n    const canvas = canvasRef.current;\r\n\r\n    ctx.save();\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // results are non-empty\r\n    if (results.multiHandLandmarks && results.multiHandedness) {\r\n      // console.log(results);\r\n      for (let i = 0; i < results.multiHandLandmarks.length; i++) {\r\n        const [numPrediction, letterPrediction] = displayHand(\r\n          results.image,\r\n          results.multiHandedness[i],\r\n          results.multiHandLandmarks[i],\r\n          ctx,\r\n          numPredictionText\r\n        );\r\n\r\n        // changes prediction text... after getting the same prediction 10 times\r\n        // console.log(letterPrediction);\r\n        updateNumUI(numPrediction);\r\n        updateLetterUI(letterPrediction);\r\n      }\r\n    } else { // empty results\r\n      displayEmpty(ctx, numPredictionText);\r\n      displayEmpty(ctx, letterPredictionText);\r\n    }\r\n    ctx.restore();\r\n  };\r\n\r\n  // called to send picture to hands\r\n  const sendPicture = async (hands) => {\r\n    // validate videofeed\r\n    if (\r\n      typeof webcamRef.current !== 'undefined' &&\r\n      webcamRef.current !== null &&\r\n      webcamRef.current.video.readyState === 4\r\n    ) {\r\n      window.webcamEl = webcamRef.current.video;\r\n\r\n      const video = webcamRef.current.video;\r\n      const vw = webcamRef.current.video.videoWidth;\r\n      const vh = webcamRef.current.video.videoHeight;\r\n\r\n      video.width = vw;\r\n      video.height = vh;\r\n\r\n      canvasRef.current.width = vw;\r\n      canvasRef.current.height = vh;\r\n\r\n      /*\r\n      const hand = await net.estimateHands(video);\r\n      console.log(hand);\r\n      if (hand.length > 0) {\r\n        const GE = new fp.GestureEstimator([\r\n          fp.Gestures.VictoryGesture,\r\n          fp.Gestures.ThumbsUpGesture,\r\n        ]);\r\n        const gesture = await GE.estimate(hand[0].landmarks, 4);\r\n        if (gesture.gestures !== undefined && gesture.gestures.length > 0) {\r\n          console.log(gesture.gestures);\r\n          const confidence = gesture.gestures.map(\r\n            (prediction) => prediction.confidence\r\n          );\r\n          const maxConfidence = confidence.indexOf(\r\n            Math.max.apply(null, confidence)\r\n          );\r\n          console.log(gesture, gesture.gestures[maxConfidence].name);\r\n        }\r\n      } */\r\n\r\n      if (cam === null) {\r\n        console.log('setting up mediapipe camera for the first time');\r\n        cam = new Camera(video, {\r\n          onFrame: async () => {\r\n            window.current_screenshot = video;\r\n            await hands.send({ image: video });\r\n          },\r\n          width: 640,\r\n          height: 480\r\n        });\r\n        cam.start();\r\n      }\r\n    }\r\n  };\r\n\r\n  // initialize camera, will be filled when page loaded\r\n  let cam = null;\r\n\r\n  const setupWidgets = async () => {\r\n    // const net = await handpose.load();\r\n    console.log('setting up widgets');\r\n\r\n    // initialize mediapipe ML model\r\n    const hands = new Hands({\r\n      locateFile: (file) => {\r\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;\r\n      }\r\n    });\r\n    hands.setOptions({\r\n      maxNumHands: 1,\r\n      minDetectionConfidence: 0.8,\r\n      minTrackingConfidence: 0.8\r\n    });\r\n    hands.onResults(onResults);\r\n\r\n    // initialize custom hand recognizer\r\n    window.recognizer = await tf.loadLayersModel(\r\n      'https://aelu419.github.io/TensorFlowPlayground/asl_cnn/model.json'\r\n    );\r\n    window.recognizer.add(tf.layers.softmax());\r\n    console.log(window.recognizer);\r\n\r\n    // automatically send webcam picture to hands\r\n    const refresh = () => {\r\n      // console.log('refresh called');\r\n      sendPicture(hands);\r\n    };\r\n    setInterval(refresh, 1000);\r\n  };\r\n\r\n  useEffect(() => { setupWidgets(); }, []);\r\n\r\n  return (\r\n    <div className='App'>\r\n      <header>\r\n        <Webcam ref={webcamRef} className='webcam' />\r\n        <canvas ref={canvasRef} className='canvas' />\r\n      </header>\r\n      <div className='blog-slider'>\r\n        <p style={{ textAlign: 'center' }}>Spread you hand towards the camera like a 5 to calibrate</p>\r\n        <div ref={numContainerRef} className='numContainer'>\r\n          <h4 ref={numPredictionText} style={{ textAlign: 'center' }}>No Prediction</h4>\r\n          <div className='colContainer'>\r\n            <div ref={zeroDiv} className='col'><p>0</p></div>\r\n            <div ref={oneDiv} className='col'><p>1</p></div>\r\n            <div ref={twoDiv} className='col'><p>2</p></div>\r\n            <div ref={threeDiv} className='col'><p>3</p></div>\r\n            <div ref={fourDiv} className='col'><p>4</p></div>\r\n            <div ref={fiveDiv} className='col'><p>5</p></div>\r\n          </div>\r\n        </div>\r\n\r\n        <div ref={letterContainerRef} className='letterContainer hidden'>\r\n          <h4 ref={letterPredictionText} style={{ textAlign: 'center' }}>No Prediction</h4>\r\n          <div className='colContainer'>\r\n            <div ref={mDiv} className='col'>M</div>\r\n            <div ref={lDiv} className='col'>L</div>\r\n            <div ref={hDiv} className='col'>H</div>\r\n          </div>\r\n        </div>\r\n        <div className='toggleContainer'>\r\n          <p>Num Recognition</p>\r\n          <div>\r\n            <input\r\n              type='checkbox'\r\n              id='switch'\r\n              onChange={() => {\r\n                if (numMode.current) {\r\n                  numContainerRef.current.classList.add('hidden');\r\n                  letterContainerRef.current.classList.remove('hidden');\r\n                } else {\r\n                  letterContainerRef.current.classList.add('hidden');\r\n                  numContainerRef.current.classList.remove('hidden');\r\n                }\r\n                numMode.current = !numMode.current;\r\n              }}\r\n            /><label for='switch'>Toggle</label>\r\n            <strong>Toggle Mode</strong>\r\n          </div>\r\n          <p>letter Recognition</p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\n//setup page\r\nReactDOM.render(\r\n  <App />,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\n"],"sourceRoot":""}